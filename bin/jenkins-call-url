#!/usr/bin/env python
#Created by Sam Gleske
#Tue Mar 21 17:24:36 PDT 2017
#Ubuntu 16.04.1 LTS
#Linux 4.4.0-59-generic x86_64
#Python 2.7.12
#Reads Jenkins API and can make calls to arbitrary Jenkins URL endpoints.

from httplib import HTTPSConnection
import argparse
import base64
import json
import os
import ssl
import sys
import time
import urllib
import urllib2

parser = argparse.ArgumentParser(description="Reads Jenkins API and can make calls to arbitrary Jenkins URL endpoints.  Useful for calling Jenkins URLs for killing jobs or executing script console scripts.", epilog="""
environment variables:
  JENKINS_WEB           Root URL to a Jenkins server.  See also -s.
  JENKINS_USER          Username to authenticate with Jenkins.
  JENKINS_PASSWORD      Password to authenticate with Jenkins.
  JENKINS_CA_FILE       Path to CA chain file to validate TLS connections.  See also -c.
  JENKINS_HEADERS_FILE  Path to file to persist HTTP headers.  See also --save-headers or --load-headers.

exit status:
  0                     SUCCESS script run.
  1                     Any script run status other than SUCCESS.
""", formatter_class=argparse.RawTextHelpFormatter)
parser.add_argument('--curl', action='store_true', dest='print_curl', help='Print a fully formatted curl command which includes all options for debugging and exit.')
parser.add_argument('--curl-init', action='store_true', dest='print_curl_init', help='Print a formatted initial curl command for debugging and exit.')
parser.add_argument('--data-string', action="append", default=[], metavar='arg', dest='http_data_strings', help='Data to pass via message body of an HTTP request and prepends -d.  Can specify one or more -d data-file.')
parser.add_argument('--force-crumb', action='store_true', dest='force_crumb', help='Force resolving the CSRF crumb even if --load-headers option is used.')
parser.add_argument('--load-headers', default=os.getenv('JENKINS_HEADERS_FILE', ''), metavar='json-file', dest='load_headers_file', help='Loads HTTP headers from a JSON file to use.  It can also be set via JENKINS_HEADERS_FILE environment variable.')
parser.add_argument('--save-headers', default=os.getenv('JENKINS_HEADERS_FILE', ''), metavar='json-file', dest='save_headers_file', help='Saves HTTP headers to a JSON file for reuse later.  It can also be set via JENKINS_HEADERS_FILE environment variable.')
parser.add_argument('-a, --automatic-jenkins-server', action='store_true', dest='auto_jenkins_web', help='Automatically determine the Jenkins root based off of JENKINS_URL url.  This option ignores -s.')
parser.add_argument('-c, --ca-file', default=os.getenv('JENKINS_CA_FILE'), metavar='CERT_PEM', dest='pinned_cert', help='Path to pinned CA chain in PEM format.  Can be self signed to guarantee secure connection.  It can also be set via JENKINS_CA_FILE environment variable.')
parser.add_argument('-d, --data-file', action="append", default=[], metavar='data-file', dest='http_data_files', help='Data to pass via message body of an HTTP request.  Can specify one or more -d data-file.')
parser.add_argument('-m, --http-method', default='GET', metavar='method', dest='http_method', help='HTTP method to use when calling Jenkins.  Valid values are GET or POST.')
parser.add_argument('-s, --jenkins-server', default=os.getenv('JENKINS_WEB', 'http://localhost:8080'), metavar='JENKINS_WEB', dest='jenkins_web', help='Root web URL for the Jenkins server.  It can also be set via JENKINS_WEB environment variable.')
parser.add_argument('-v, --verbosity', action="count", dest='verbosity', help="Increase output verbosity.")
parser.add_argument('JENKINS_URL', help='The URL to a Jenkins endpoint to call.')
args = parser.parse_args()

def trim_url_slash(url):
    return url[:-1] if url[-1:] == '/' else url

def getUrl(url, headers, data=None, method='GET'):
    responseCode = -1
    responseString = ""
    responseErrorReason = None
    try:
        if url.startswith('https'):
            #https://docs.python.org/3/library/ssl.html#ssl-security
            context = ssl.create_default_context()
            if args.pinned_cert:
                context.load_verify_locations(cafile=args.pinned_cert)
            else:
                context.load_default_certs()
            req = urllib2.Request(url, data=data, headers=headers)
            if method != 'GET':
                req.get_method = lambda: method
            urlconn = urllib2.urlopen(req, context=context)
        else:
            req = urllib2.Request(url=url, data=data, headers=headers)
            if method != 'GET':
                req.get_method = lambda: method
            urlconn = urllib2.urlopen(req)
        responseString = urlconn.read()
        responseCode = urlconn.getcode()
        urlconn.close()
    except urllib2.HTTPError as e:
        responseCode = e.code
        responseErrorReason = e.reason
    return (responseCode, responseString, responseErrorReason)

def getJSONUrl(url, headers):
    if not url.endswith('/api/json'):
        url = url + '/api/json'
    code, response, reason = getUrl(url, headers)
    if reason:
        printErr("HTTP ERROR %s: %s\n%s" % (str(code), reason, url))
        sys.exit(1)
    parsed = json.loads(response)
    return parsed

def printCurl(headers, url=trim_url_slash(args.jenkins_web)):
    curl='curl'
    if args.http_method != 'GET' and url != trim_url_slash(args.jenkins_web):
        curl += " -X%s" % args.http_method
    if len(args.http_data_files) > 0 and url != trim_url_slash(args.jenkins_web):
        curl += ' --data-urlencode "'
        if len(args.http_data_strings) > 0:
            for s in args.http_data_strings:
                curl += '%s' % s
        for f in args.http_data_files:
            curl += '$(<%s)' % f
        curl += '"'
    if args.pinned_cert:
        curl += ' --cacert %s' % args.pinned_cert
    for k,v in headers.items():
        curl += " -H '%s:%s'" % (k, v)
    print curl, url
    sys.exit(1)

#print to stderr
def printErr(message=''):
    sys.stderr.write(message + '\n')
    sys.stderr.flush()

if not args.http_method in ['GET', 'POST']:
    printErr("Invalid --http-method specified: %s" % args.http_method)
    parser.print_help()
    sys.exit(1)


#build credentials
username=os.getenv('JENKINS_USER')
password=os.getenv('JENKINS_PASSWORD')

if len(args.load_headers_file) > 0 and os.path.exists(args.load_headers_file):
    if args.verbosity >= 2:
        printErr("Loading HTTP headers from JSON file.")
    with open(args.load_headers_file) as f:
        headers = json.load(f)
else:
    headers = {
        'Accept-Encoding': '',
        'Connection': 'close',
        'Host': args.jenkins_web.split('/')[2].split(':')[0],
        'User-Agent': ''
    }

if 'Authorization' in headers:
    if args.verbosity >= 2:
        printErr("Reusing Authorization from HTTP headers file.")
else:
    if not username == None:
        if args.verbosity >= 2:
            printErr("Logging in as user %s." % username)
        headers['Authorization'] = "Basic %s" % base64.b64encode("%s:%s" % (username, password)).decode('ascii')

if args.print_curl_init:
    printCurl(headers)

#complete arguments for use
jenkins_url = trim_url_slash(args.JENKINS_URL)
jenkins_web = ''
jenkins_root_api_response = {}

if args.auto_jenkins_web:
    if args.verbosity >= 2:
        printErr("Automatically resolving JENKINS_WEB.")
    jenkins_web = jenkins_url
    if jenkins_web[-8:] == 'api/json':
        jenkins_web = jenkins_web[:-8]
    if jenkins_web[-1:] != '/':
        jenkins_web += '/'
    while len(jenkins_web.split('/')) > 3:
        jenkins_web = '/'.join(jenkins_web.split('/')[:-1])
        if jenkins_web.split('/')[-1] in ['job', 'view']:
            continue
        jenkins_root_api_response = getJSONUrl(jenkins_web + '/api/json', headers)
        if 'useCrumbs' in jenkins_root_api_response:
            #use -a to update host header
            headers['Host'] = jenkins_web.split('/')[2].split(':')[0]
            break

if len(args.load_headers_file) == 0 or args.force_crumb or not os.path.exists(args.load_headers_file):
    if not args.auto_jenkins_web:
        jenkins_web = trim_url_slash(args.jenkins_web)
        if not jenkins_url.startswith(jenkins_web):
            printErr("ERROR: JENKINS_URL does not start with JENKINS_WEB.  See --help for -s or -a.")
            sys.exit(2)
        jenkins_root_api_response = getJSONUrl(jenkins_web + '/api/json', headers)

    #detect CSRF protection
    if jenkins_root_api_response['useCrumbs']:
        if args.verbosity >= 2:
            printErr("CSRF protection enabled.")
        csrf_crumb = getJSONUrl(jenkins_web + '/crumbIssuer', headers)
        headers[csrf_crumb["crumbRequestField"]] = csrf_crumb["crumb"]
    else:
        if args.verbosity >= 2:
            printErr("CSRF protection disabled.")
else:
    if args.verbosity >= 2:
        printErr("Reusing CSRF crumb from HTTP headers file.")

#include the full operation
if args.print_curl:
    printCurl(headers, url=jenkins_url)

if args.verbosity >= 1:
    printErr("%s %s" % (args.http_method, jenkins_url))

#prepare the HTTP message body payload
data=None
if len(args.http_data_files) > 0:
    data = ""
    for string in args.http_data_strings:
        data += string
    for path in args.http_data_files:
        with open(path) as f:
            data += f.read()

#Call the URL
code, response, reason = getUrl(jenkins_url, headers, method=args.http_method, data=data)
if args.verbosity >= 1:
    printErr("Response (HTTP %s):" % str(code))
#print without newline at end
if len(response) > 0:
    sys.stdout.write(response)
    sys.stdout.flush()

if len(args.save_headers_file) > 0:
    if args.verbosity >= 2:
        printErr("Saving HTTP headers to file.")
    with open(args.save_headers_file, 'w') as f:
        json.dump(headers,f)

STATUS = 0
if reason:
    STATUS=1
    if args.verbosity >= 1:
        printErr(reason)
sys.exit(STATUS)
